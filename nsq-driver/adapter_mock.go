// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package nsqdriver

import (
	"github.com/nsqio/go-nsq"
	"sync"
)

var (
	lockAdapterMockAddListener  sync.RWMutex
	lockAdapterMockAddPublisher sync.RWMutex
)

// AdapterMock is a mock implementation of Adapter.
//
//     func TestSomethingThatUsesAdapter(t *testing.T) {
//
//         // make and configure a mocked Adapter
//         mockedAdapter := &AdapterMock{
//             AddListenerFunc: func(topic string, channel string, handler nsq.HandlerFunc) (*nsq.Consumer, error) {
// 	               panic("mock out the AddListener method")
//             },
//             AddPublisherFunc: func() (Publisher, error) {
// 	               panic("mock out the AddPublisher method")
//             },
//         }
//
//         // use mockedAdapter in code that requires Adapter
//         // and then make assertions.
//
//     }
type AdapterMock struct {
	// AddListenerFunc mocks the AddListener method.
	AddListenerFunc func(topic string, channel string, handler nsq.HandlerFunc) (*nsq.Consumer, error)

	// AddPublisherFunc mocks the AddPublisher method.
	AddPublisherFunc func() (Publisher, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddListener holds details about calls to the AddListener method.
		AddListener []struct {
			// Topic is the topic argument value.
			Topic string
			// Channel is the channel argument value.
			Channel string
			// Handler is the handler argument value.
			Handler nsq.HandlerFunc
		}
		// AddPublisher holds details about calls to the AddPublisher method.
		AddPublisher []struct {
		}
	}
}

// AddListener calls AddListenerFunc.
func (mock *AdapterMock) AddListener(topic string, channel string, handler nsq.HandlerFunc) (*nsq.Consumer, error) {
	if mock.AddListenerFunc == nil {
		panic("AdapterMock.AddListenerFunc: method is nil but Adapter.AddListener was just called")
	}
	callInfo := struct {
		Topic   string
		Channel string
		Handler nsq.HandlerFunc
	}{
		Topic:   topic,
		Channel: channel,
		Handler: handler,
	}
	lockAdapterMockAddListener.Lock()
	mock.calls.AddListener = append(mock.calls.AddListener, callInfo)
	lockAdapterMockAddListener.Unlock()
	return mock.AddListenerFunc(topic, channel, handler)
}

// AddListenerCalls gets all the calls that were made to AddListener.
// Check the length with:
//     len(mockedAdapter.AddListenerCalls())
func (mock *AdapterMock) AddListenerCalls() []struct {
	Topic   string
	Channel string
	Handler nsq.HandlerFunc
} {
	var calls []struct {
		Topic   string
		Channel string
		Handler nsq.HandlerFunc
	}
	lockAdapterMockAddListener.RLock()
	calls = mock.calls.AddListener
	lockAdapterMockAddListener.RUnlock()
	return calls
}

// AddPublisher calls AddPublisherFunc.
func (mock *AdapterMock) AddPublisher() (Publisher, error) {
	if mock.AddPublisherFunc == nil {
		panic("AdapterMock.AddPublisherFunc: method is nil but Adapter.AddPublisher was just called")
	}
	callInfo := struct {
	}{}
	lockAdapterMockAddPublisher.Lock()
	mock.calls.AddPublisher = append(mock.calls.AddPublisher, callInfo)
	lockAdapterMockAddPublisher.Unlock()
	return mock.AddPublisherFunc()
}

// AddPublisherCalls gets all the calls that were made to AddPublisher.
// Check the length with:
//     len(mockedAdapter.AddPublisherCalls())
func (mock *AdapterMock) AddPublisherCalls() []struct {
} {
	var calls []struct {
	}
	lockAdapterMockAddPublisher.RLock()
	calls = mock.calls.AddPublisher
	lockAdapterMockAddPublisher.RUnlock()
	return calls
}
